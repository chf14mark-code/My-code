# wordle

import sys
import random

from PyQt5.QtWidgets import QWidget, QApplication, QLineEdit, QMessageBox,QGridLayout
from PyQt5.QtCore import Qt, QEvent


def import_words():
    try:
        with open("dictionary.txt", "r") as file:
            words = file.read().splitlines()
            return words
    except FileNotFoundError:
        print("Dictionary file not found. Creating new one.")

word_list = import_words()



max_rows = 5  # number of attempts the player has


class wordle_app(QWidget):

    def __init__(self):
        super().__init__()
        self.answer = random.choice(word_list).lower()  # randomly choose a word from word_list
        self.grid = []  # store the grid of input boxes
        self.length = len(self.answer)
        self.current_row = 0  # track the current attempt
        self.current_column = 0
        self.init_UI()  # call the init_UI method

    def init_UI(self):
        self.setWindowTitle("Wordle App")  # set the window title
        self.setFixedSize(70 * self.length, 400)  # prevent the window from being resized

        layout = QGridLayout()
        self.setLayout(layout)  # set the window layout using a grid layout

        for row in range(max_rows):  # create rows based on the maximum number of attempts
            self.row_input = []  # store all boxes in the current row

            for col in range(self.length):
                box = QLineEdit(self)
                box.setFixedSize(60, 60)
                box.setMaxLength(1)  # allow only one character per box
                box.setAlignment(Qt.AlignCenter)
                box.installEventFilter(self)  # override the default event filter to handle key presses
                self.row_input.append(box)
                layout.addWidget(box, row, col)

                box.setReadOnly(row != 0)  # allow input only in the first row initially

                # detect user input and move to the next box automatically
                box.textChanged.connect(
                    lambda text, r=row, c=col: self.move_next_box(r, c)
                )

            self.grid.append(self.row_input)

    @staticmethod
    def gray():  # return the CSS style for the gray color
        return "background-color: #787c7e;"

    @staticmethod
    def green():  # return the CSS style for the green color
        return "background-color: #6aaa64;"

    @staticmethod
    def yellow():  # return the CSS style for the yellow color
        return "background-color: #c9b458;"

    def move_next_box(self, r, c):
        if len(self.grid[r][c].text()) == 1:
            if c + 1 < self.length:
                self.grid[r][c + 1].setFocus()  # move focus to the next box
                if self.current_column + 1 < self.length:
                    self.current_column += 1

    def eventFilter(self, obj, event):
        if event.type() == event.KeyPress:  # check if a key is pressed
            if event.key() in (Qt.Key_Enter, Qt.Key_Return):  # detect Enter or Return key
                self.submit_row()  # submit the current row
                return True
            elif event.key() == Qt.Key_Backspace and len(self.grid[self.current_row][self.current_column].text()) == 0:
                self.backspace()
                return True
        return super().eventFilter(obj, event)  # use the default event filter otherwise

    def answer_list(self):
        return list(self.answer)  # convert the answer word into a list of characters

    def backspace(self):
        if self.current_column - 1 >= 0:
            self.grid[self.current_row][self.current_column - 1].setFocus()
            self.grid[self.current_row][self.current_column - 1].setText("")
            self.current_column = self.current_column - 1

    def submit_row(self):
        # join all characters in the current row into a single word
        user_answer = "".join(box.text() for box in self.grid[self.current_row]).lower()

        char_answer = self.answer_list()

        if user_answer not in word_list:
            return True

        if len(user_answer) < self.length:
            return  # stop if not all boxes are filled

            # checking the letter if it in the correct position
        for i, box in enumerate(self.grid[self.current_row]):
                if user_answer[i] == char_answer[i]:
                    box.setStyleSheet(self.green())
                    char_answer[i] = None

        # checking the letter if it in the word
        for i, box in enumerate(self.grid[self.current_row]):
            if char_answer[i] is None:
                continue
            if user_answer[i] in char_answer[i]:
                box.setStyleSheet(self.yellow())
                char_answer[i] = None
            else:
                box.setStyleSheet(self.gray())

        # if the user guesses the word correctly, display a winning message
        if user_answer == self.answer:
            QMessageBox.information(
                self, "YOU WIN", f"Congratulations, the answer was {self.answer} ðŸ†"
            )
            self.close()

        # display a losing message if the player runs out of attempts
        if self.current_row > max_rows:
            QMessageBox.critical(self, "YOU LOSE", "TRY AGAIN!")
            self.close()

        # make the previous row uneditable
        for box in self.grid[self.current_row]:
            box.setReadOnly(True)

        if self.current_row + 1 < max_rows:
            # allow editing for the next row
            for box in self.grid[self.current_row + 1]:
                box.setReadOnly(False)

            # move focus to the first box of the next row
            self.grid[self.current_row + 1][0].setFocus()

        self.current_row += 1
        self.current_column = 0

        # display a losing message if the player runs out of attempts
        if self.current_row == max_rows:
            QMessageBox.critical(self, "YOU LOSE", f"TRY AGAIN! ({self.answer})")
            self.close()

# check if this file is being run as the main program
if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = wordle_app()
    window.show()
    sys.exit(app.exec_())
